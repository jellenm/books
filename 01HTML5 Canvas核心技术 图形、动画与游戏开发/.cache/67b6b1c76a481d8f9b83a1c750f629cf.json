{"dependencies":[],"generated":{"js":"\"use strict\";\n\n/*\n * Copyright (C) 2012 David Geary. This code is from the book\n * Core HTML5 Canvas, published by Prentice-Hall in 2012.\n *\n * License:\n *\n * Permission is hereby granted, free of charge, to any person \n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * The Software may not be used to create training material of any sort,\n * including courses, books, instructional videos, presentations, etc.\n * without the express written consent of David Geary.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// Painters...................................................................\n\n// Painters paint sprites with a paint(sprite, context) method. ImagePainters\n// paint an image for their sprite.\n\nwindow.ImagePainter = function (imageUrl) {\n  this.image = new Image();\n  this.image.src = imageUrl;\n};\n\nImagePainter.prototype = {\n  image: undefined,\n\n  paint: function paint(sprite, context) {\n    if (this.image !== undefined) {\n      if (!this.image.complete) {\n        this.image.onload = function (e) {\n          sprite.width = this.width;\n          sprite.height = this.height;\n\n          context.drawImage(this, // this is image\n          sprite.left, sprite.top, sprite.width, sprite.height);\n        };\n      } else {\n        context.drawImage(this.image, sprite.left, sprite.top, sprite.width, sprite.height);\n      }\n    }\n  }\n};\n\nwindow.SpriteSheetPainter = function (cells) {\n  this.cells = cells;\n};\n\nSpriteSheetPainter.prototype = {\n  cells: [],\n  cellIndex: 0,\n\n  advance: function advance() {\n    if (this.cellIndex == this.cells.length - 1) {\n      this.cellIndex = 0;\n    } else {\n      this.cellIndex++;\n    }\n  },\n\n  paint: function paint(sprite, context) {\n    var cell = this.cells[this.cellIndex];\n    context.drawImage(spritesheet, cell.left, cell.top, cell.width, cell.height, sprite.left, sprite.top, cell.width, cell.height);\n  }\n};\n\n// Sprite Animators...........................................................\n\n// Sprite animators have an array of painters that they succesively apply\n// to a sprite over a period of time. Animators can be started with \n// start(sprite, durationInMillis, restoreSprite)\n\nwindow.SpriteAnimator = function (painters, elapsedCallback) {\n  this.painters = painters;\n  if (elapsedCallback) {\n    this.elapsedCallback = elapsedCallback;\n  }\n};\n\nSpriteAnimator.prototype = {\n  painters: [],\n  duration: 1000,\n  startTime: 0,\n  index: 0,\n  elapsedCallback: undefined,\n\n  end: function end(sprite, originalPainter) {\n    sprite.animating = false;\n\n    if (this.elapsedCallback) {\n      this.elapsedCallback(sprite);\n    } else {\n      sprite.painter = originalPainter;\n    }\n  },\n\n  start: function start(sprite, duration) {\n    var endTime = +new Date() + duration,\n        period = duration / this.painters.length,\n        interval = undefined,\n        animator = this,\n        // for setInterval() function\n    originalPainter = sprite.painter;\n\n    this.index = 0;\n    sprite.animating = true;\n    sprite.painter = this.painters[this.index];\n\n    interval = setInterval(function () {\n      if (+new Date() < endTime) {\n        sprite.painter = animator.painters[++animator.index];\n      } else {\n        animator.end(sprite, originalPainter);\n        clearInterval(interval);\n      }\n    }, period);\n  }\n};\n\n// Sprites....................................................................\n\n// Sprites have a name, a painter, and an array of behaviors. Sprites can\n// be updated, and painted.\n//\n// A sprite's painter paints the sprite: paint(sprite, context)\n// A sprite's behavior executes: execute(sprite, context, time)\n\nwindow.Sprite = function (name, painter, behaviors) {\n  if (name !== undefined) this.name = name;\n  if (painter !== undefined) this.painter = painter;\n  if (behaviors !== undefined) this.behaviors = behaviors;\n\n  return this;\n};\n\nSprite.prototype = {\n  left: 0,\n  top: 0,\n  width: 10,\n  height: 10,\n  velocityX: 0,\n  velocityY: 0,\n  visible: true,\n  animating: false,\n  painter: undefined, // object with paint(sprite, context)\n  behaviors: [], // objects with execute(sprite, context, time)\n\n  paint: function paint(context) {\n    if (this.painter !== undefined && this.visible) {\n      this.painter.paint(this, context);\n    }\n  },\n\n  update: function update(context, time) {\n    for (var i = this.behaviors.length; i > 0; --i) {\n      this.behaviors[i - 1].execute(this, context, time);\n    }\n  }\n};"},"hash":"cefa7bf0f75e755cc0fb30780bd67f67"}