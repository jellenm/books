{"dependencies":[],"generated":{"js":"/*\r\n\tchunk 利用Array.from 将一个一维数组 改为以size为单位的二维数组\r\n */\r\nconst chunk = (arr,size) => Array.from({length:Math.ceil(arr.length/size)},(v,i)=>arr.slice(i*size,(i+1)*size));\r\nconsole.log('chunk',chunk([1,2,3,4,5],2));\r\n\r\n/*\r\n\tcompact 利用Array.filter，返回符合条件的数值，形成新数组\r\n */\r\nconst compact = arr=> arr.filter(Boolean); //compact = arr=> arr.filter( (v,i)=> v>1 ) \r\nconsole.log('compact',compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]));\r\n\r\n/*\r\n\tcountOccurrences 数组内等于某个值的个数\r\n */\r\nconst countOccurrences = (arr,num)=>arr.reduce((p,n)=>(n==num)?p+=1:p+=0,0);\r\nconsole.log('countOccurrences',countOccurrences([1,2,1,11],1));\r\n\r\n/*\r\n\tdeepFlatten 将二维数组遍历成一维数组\r\n */\r\nconst deepFlatten = arr => [].concat(...arr.map((v,i)=>Array.isArray(v)?deepFlatten(v):v));\r\n// const deepFlatten = arr => [].concat(...arr.map((v,i)=>{ return Array.isArray(v)?deepFlatten(v):v}));\r\nconsole.log('deepFlatten',deepFlatten([1,[2,3],4]));\r\n\r\n\r\n/*\r\n\tdifference 两个数组间的不同(b不同于a的)\r\n */\r\nconst difference = (a,b) => {\r\n\tlet s = new Set(a);\r\n\treturn b.filter( v=>!s.has(v));\r\n}\r\nconsole.log('difference',difference([1,2,3,4,5],[2,3,8,7]));\r\n\r\n\r\n/*\r\n\tdifferenceWith 找出连个数组中前一个数组的round 后面数组是没有的的数值\r\n */\r\nconst differenceWith = (arr,val,comp)=>arr.filter(a=>val.findIndex(b=>comp(a,b)) === -1);\r\nconsole.log('differenceWith',differenceWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0], (a, b) => Math.round(a) === Math.round(b)));\r\n\r\n\r\n/*\r\n\t数组中没有重复的数值\r\n */\r\nconst filterNonUnique = arr => arr.filter(v=>arr.indexOf(v)===arr.lastIndexOf(v));\r\nconsole.log('filterNonUnique',filterNonUnique([1,2,3,4,5,6,4]));"},"hash":"ff8ff114d6238726bcd28d6c4a9c6afa"}